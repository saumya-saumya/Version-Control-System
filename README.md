# Version-Control-System
![alt text](https://github.com/saumya-saumya/Version-Control-System/blob/master/543_P3_KARS/VCS.png)
## Part 1
Use Case <br>
Title: Create Repository <br>
Tag-line: Create a repository for the given project source tree (including all its files and their folder paths) within the project.<br>
<br>
Summary: The user needs to keep track of various snapshots of their project.  Each snapshot includes the current state of each file in their project tree at a specific moment during project development.  In order to keep track of each snapshot, we create a repository (repo) in the given target folder and copy a snapshop of the source tree in the given source folder.  The entire source project tree folder (including its root folder) is replicated within (and immediately under) the target repository root folder.  Additionally, on creation, a manifest (i.e., a snapshot summary) for this command is created listing the command particulars (i.e., the command line used), the date and time of the command, and for each project source file a line describing that source file (AKA that artifact) in the project along with its project folder's relative path.  Because we expect, eventually, to store more than one artifact of each project file, we put the first artifact of a file under a new (non-project) leaf folder, where the leaf folder is given the file's name and the artifact gets an artifact ID (a code name).  Note the contents of the artifact file is the same as its corresponding project source file snapshot. The leaf folder appears in the repository in same relative position as its corresponding file appears in the project source folder.  The artifact ID format is described below.
<br><br>
Simplifying assumptions:<br>
1. All files in the project tree (ptree) will be included.  (No exception, black-list.)<br>
2. No frills: You may ignore user input mistakes.<br>
3. A file artifact will consist of the full file contents.  (No deltas/diffs.)<br>
4. The repo will include the ptree folder hierarchy. <br>
5. Each ptree file will get a “leaf” folder of the same name to hold that file's artifacts (initially just the first artifact).  Thus, if ptree folder xcp/ has two files fred.c and jack.c, the repo will have folder xcp/ as well as leaf sub-folders fred.c/ and jack.c/ – where leaf folder fred.c/ will contain all that ptree file's fred.c artifacts and leaf folder jack.c/  will contain all that ptree file's jack.c artifacts.<br>
6. We will create an artifact ID (ArtID) code name as discussed below. <br>
7. The artifact (file version) that is in a leaf folder gets named by it's ArtID code name. <br>
8. Assume that both given source and empty target folders exist, and that disk space is adequate.<br>
9. A command-line interface within a web page (e.g., edit boxes & “Create” button) is sufficient.<br><br>
Artifact ID (ArtID) code names
<br>Weighted checksum: The code name will be a rolling multi-byte weighted checksum of all the characters (bytes) in the file followed by a hyphen and an “L” and the integer file size, followed by the file's extension.  The weights by which each character in a group are multiplied are 1, 7, 3, 7, and, 11.  Thus, if the file contents is "HELLO WORLD", the checksum S is:  S = 4540 = 1*H + 7*E +3*L +7*L + 11*O + 1*'  ' + 7*W + 3*O + 7*R + 11*L + 1*D;
and the file size is 11.  (Note, the ASCII numeric value of each character is used and we indicated the space character by '  '.)  For this version of the source file fred.txt, the AID code name would be “4540-L11.txt”, in a leaf folder named “fred.txt”.
<br>Modulus: Because the sum can get rather large for a big file, make sure the sum never gets too large by wrapping it using the following prime modulus operator: m == (2^31) - 1 == 2,147,483,647



## Part-2 
This project is to build the second part of our VCS. <br> 
In this project part, we add four new features: check-out, check-in (mostly already done), listing the existing manifest files (or a portion that fits in the display view), and labeling, again in HTML+Javascript+Node+Express. For background material on actual modern VCSs, review on-line user documentation for Fossil, Git, and/or Subversion, etc.  Note, in the terminology of a VCS, an “artifact” is a particular version of a file; multiple versions of the file are artifacts. <br> <br>
Label Command  <br>
The labeling feature allows the user to add a label (a text string) to a manifest file, in order to make it easier to remember and identify a particular project snapshot when issuing commands to our VCS.  A manifest file must support up to four (4) different labels at the same time.  (More is okay.)  We can presume that the user is nice and always supplies a unique label – so we don't have to check for the label already existing in some other manifest file.  A label is supposed to uniquely ID a manifest.  We can also assume that only the first 30 characters of the label (a string) are needed.  To add a label to a manifest file, the user uses a Label command, and along with a label string argument he/she must also specify either the target manifest's filename or an existing label associated with that manifest.  Once a manifest is labeled, the user can refer to the manifest by that label name in any other VCS commands. <br> <br>
Check-Out Command 
 <br>The check-out ability lets a user recreate a specific version (snapshot) of the project tree.  They do this by selecting a particular manifest file in the repo, as an argument.   Of course, a manifest file specifies every version of every file from a particular version of a project tree.  Note that a given repo folder only deals with one project (e.g., snapshots only for the Skyrocket project, or the Red-Bunny project, or the Halo project), but the repo can contain many versions (snapshots) of that one project.  A snapshot can be created by anyone who has previously checked out a version of that project (but you do not have to verify this).  On check-out, the recreated project tree is installed in an empty folder, which the user also selects as a second argument.   We can assume that the target folder is empty.  The checkout command also creates a new manifest file, of the checked out version, in the repo.  The user should be able to specify the manifest file using a label, if it has one. <br> <br>
 
Check-In Command  <br> <br>
The check-in ability lets the user update the repository (repo) with new version (snapshot) of the project; meaning you have to add into the repo any changed files in the project tree.  So, each check-in is a (potentially) different "version" of the project tree, and you create for it a new manifest file.  This allows the user to track the modification history from a given project tree back, through various project versions, all the way to the repo's creation.  Note that we assume labels are forever (the user doesn't remove a label).   The folder containing a version of the project tree that the user specifies as an argument to the check-in command should have earlier been the target of a check-out command, and we will assume that this is always true.  Therefore, in the repo's manifest files, we can trace from a given check-in (from a user's folder) back to the original check-out into that user's folder from a snapshot of some other user's project tree in some other folder, etc., all the way back to the original create-repo command.  Note that your manifest files should reflect this ability, as it will be needed later. <br>


Check-In Notes  <br>
Note that almost all of the check-in code has already been developed for the previous Create Repo project part.  A few new issues must be handled: <br>
1. For a newer version of a file (with the same project folder relative path) as a file in the repo, the leaf folder will already exist with an earlier version of that file having a different artifact ID. You merely have to add the newer version file into the same leaf folder with its own artifact ID name. <br>
2. If a project file has the same computed artifact ID (and project folder relative path) as a file in the repo, then we can presume that it is the same file in both placed.  So, you need not use this project file to overwrite the existing identical copy in the repo; but you can do such an overwrite if that seems easier. <br>
3. Also, you will create a "check-in" manifest file for this command.  It will include the command and its arguments as well as the usual manifest information (same as for a "create-repo" command.)  Note, if your project #1 manifest didn't include the "create-repo" command and arguments that was used to create it, please upgrade so that that manifest includes these. <br>
4. Regardless of whether a project file has been changed (ie, new artifact ID) or not (ie, old duplicate artifact ID), the file-name and its artifact ID must be recorded in a new manifest file for this check-in (with the check-in command line arguments and the date-time stamp, of course). <br>
Check-Out Notes <br>
For check-out, the user supplies the repo folder name an empty target folder name and selects a manifest (representing the specific version of the project files desired).  The selection can be either a label or the manifest filename.  New issues must be handled: <br>
1. You will create a new project tree inside the empty target folder.  The files copied from the repo must be those mentioned in the selected manifest. <br>
2. Each needed repo file has an artifact ID as its filename and sits in a sub-folder that is named with its project's filename.  This repo artifact file will get copied into the empty target folder's new project tree in the correct position and with its project filename.  For example, we should be able to recreate a project tree if we executed the command sequence: a. Create-repo b. Accidentally destroy/remove our project tree c. Check-out to old now-empty project-tree folder by selecting the repo's creation manifest <br>
3. Also, you will create a "check-out" manifest file for this command.  It will include the check-out  <br>command and its arguments as well as the date and time and a line for each file checked out (just like the create-repo manifest).
Listing Command <br>
This may not need to be a command.  You should display the existing manifest file names and their labels.  If the list is too large for the display, you should display a portion of the list.  (Whether paging or scrolling or some other method is up to you.) <br> <br>

## Part -3

Introduction This is the third part of our VCS. <br>
In this project part, we add the ability to merge two project tree snapshots (that are based on the same repo, and hence the same project).  Note that we already have a natural branching effect due to check-out (of a checked-in project snapshot, AKA the Kid) coupled with tracking that project version's parent snapshot (AKA the Mom, as identified in the Kid's repo manifest). This merge ability is typically used to merge two snapshots each with their own modifications (usually in different parts/files in the project tree), or to merge a branch snapshot of modifications (e.g., a bug fix, or a new feature) back into the project mainline. We will do the merge in two parts: merge-out and merge-in.  The merge-out command will gather the information needed for the user to manually do a 3-way merge.  The merge-in command will complete the merge by "checking in" a snapshot of the user's fully merged project tree.<br><br>
Source & Target <br>
The merge-out arguments are a repo source snapshot and a target project tree (actually that target's latest snapshot).  Source snapshot is the repo 'R' snapshot.  The Target 'T' snapshot is assumed to be a snapshot that the user has just checked-in (so you don't have to do this as well).  The Target project tree is in the user's project folder from which the T snapshot was (just) checked-in.  The merge-out will add new files/folders to the T project tree.  These new files will include those in the Source that don't match (don't have the same artifact ID) as their corresponding target files.  The new mismatching file will be added, but with a suffix of “_MR” meaning “Mismatch-from-Repo”.  The corresponsing existing target file will have its filename suffixed with “_MT” meaning “Mismatch-in-Target”.  Both files will retain their existing extensions (e.g, “fred_MR.java” and “fred_MT.java”). The merge-out command will create a manifest file which includes the command and arguments, and “grandma” snapshot. <br>
Grandma <br>
For each MR and MT file, you will also add the most recent common ancestor snapshot's corresponding file.  That Grandma 'G' snapshot is the same for all these files and is determined by the chain of ancestor snapshots.  The 'G' file will get its own suffix “_MG” meaning “Mismatch-fromGrandma” (e.g., “fred_MG.java”).<br>
Merge-In The merge-in command assumes<br>
1) that the user has finished manually merging the R file changes into T files as needed (including removing the R and G files and removing the _MT file suffix), and<br>
2) has done no other repo commands since.  For example, the 3 “fred_M*.java” files will be used to create a merged “fred.java” file (without the _MT) and the _MR, and _MG files will be removed – all by the user. Merge-in is merely a duplcate of the check-in command, except that it has a different command name, and hence it will always appear as the child of a merge-out command in the repo's set of manifest files. <br>
The merge-in <br>
manifest contents are equivalent to the check-in manifest file. <br>
DAG <br>
Because the mom-kid (parent-child) relationships among the manifest files can be a DAG (directed acyclic graph), finding the grandma snapshot (the most recent common ancestor) of the source and the target is a bit more complicated than finding the common ancestor in a tree. If, in searching upward from the source or target snapshot you encounter a merge-out and merge-in pair of snapshots, you may have to follow both parent branches upward toward the root (the create-repo snapshot) because the grandma could be in either one of them.  A simple way of doing this is to pick one branch to do immediately and put the other mom-branch's snapshot (or whatever is needed to identify and use it later) on a "pending" list (or array, stack, etc.) to be dealt with if you don't find the grandma using your first pick. <br><br>
